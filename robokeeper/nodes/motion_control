#!/usr/bin/env python3
""" The motion_control node publishes jointTrajectory messages to actuate the HDT Adroit 6-dof arm to mimic a goalkeeper.
    It also actuates the arm to a specified position using moveit commander when performing the step service.

    SUBSCRIBERS:
        goalie_coord (robokeeper/GoalieCoord) - 

    PUBLIHSERS:
        move_group/display_planned_path (moveit_msgs/DisplayTrajectory)
        pincer_joint_position_controller/command (std_msgs/Float64)
        arm_controller/command (trajectory_msgs/JointTrajectory)

    
    SERVICE:
        reset (std_srvs/Empty) - resets arm position to keeper Home
        step (std_srvs/Pose) - move to a new point and add the point to
        keep (std_srvs/Empty) - reset to keeper Home
        start_keeping (std_srvs/Empty) - 
        stop_keeping (std_srvs/Empty) - 
        close (std_srvs/Empty) - close the pincer
        open (std_srvs/Empty) - open the pincer
        move_hdt (std_srvs/Empty) - 

<<<<<<< HEAD
    SUBSCRIBERS:
        ball_xyz (robokeeper/coordinates) - 
        paddle_xyz (robokeeper/coordinates) -
=======
    
>>>>>>> 229818073219848cfbb19c771df3301f151447dd
"""
import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from std_msgs.msg import Float64
from std_srvs.srv import Empty, EmptyRequest, EmptyResponse
from robokeeper.srv import Moveit, MoveitRequest, MoveitResponse, Keeper, KeeperRequest, KeeperResponse
from robokeeper.msg import coordinates
from tf.transformations import quaternion_from_euler
from geometry_msgs.msg import Pose
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint  ### Marco added this
import numpy as np
from robokeeper_library.robokeeper_functions import joint_lookup_table, traj_linear_reg

class MotionControl():
    """ class MotionControl contain all function for the node
        Provide four service
    """
    def __init__(self) -> None:
        moveit_commander.roscpp_initialize(sys.argv)
        rospy.init_node('motion', anonymous=True)
        self.scene = moveit_commander.PlanningSceneInterface()
        rospy.sleep(1)
        self.robot = moveit_commander.RobotCommander()

        # Adding collision object to the planning scene to simulate table
        base_pose = geometry_msgs.msg.PoseStamped()
        base_pose.header.frame_id = 'base_link'
        base_pose.pose.position.x = 0
        base_pose.pose.position.y = 0
        base_pose.pose.position.z = -1
        base_pose.pose.orientation.w = 1.0
        self.scene.attach_box('base_link','table', pose=base_pose, size=(5, 5, 1))
        rospy.sleep(1)
        
        # Initialize arm move group for moveit
        group_name = "arm"
        self.move_group_commander = moveit_commander.MoveGroupCommander(group_name)
        self.move_group_commander.set_max_velocity_scaling_factor(1)
        self.move_group_commander.set_max_acceleration_scaling_factor(1)
        
        # Initialize publishers
        self.display_trajectory_publisher =\
            rospy.Publisher('/move_group/display_planned_path',moveit_msgs.msg.DisplayTrajectory,queue_size=20)
        self.pincer_pos_publisher = rospy.Publisher("/pincer_joint_position_controller/command", Float64,queue_size=10)
        self.move_hdt_pub = rospy.Publisher("/arm_controller/command", JointTrajectory,queue_size=10) ### Marco added this
        
        # Initialize services
        self.reset_srv = rospy.Service("reset", Empty, self.ResetCallback)
        self.step_srv = rospy.Service("step", Moveit, self.StepCallback)
        self.keeper_srv = rospy.Service("keep", Keeper, self.KeeperCallback)
        self.keeping_srv = rospy.Service("start_keeping", Empty, self.KeepingCallback)
        self.stoping_srv = rospy.Service("stop_keeping", Empty, self.StopingCallback)
        self.close_srv = rospy.Service("close", Empty, self.CloseCallback)
        self.open_srv = rospy.Service("open", Empty, self.OpenCallback)
        self.Move_hdt_srv = rospy.Service("Move_hdt", Empty, self.Move_hdt)### Marco added this

        quaternion = quaternion_from_euler(0, 1.5707, 0, axes='sxyz')
        self.home_pose = Pose()
        self.home_pose.position.x = 0.25
        self.home_pose.position.z = -0.22
        self.home_pose.orientation.x = quaternion[0]
        self.home_pose.orientation.y = quaternion[1]
        self.home_pose.orientation.z = quaternion[2]
        self.home_pose.orientation.w = quaternion[3]

        self.now_keep = True
        self.current_y = 0

        self.msg_count = 0
        self.keeping = False
<<<<<<< HEAD
        self.sub = rospy.Subscriber("/ball_xyz", coordinates, self.BallPositionInputCallback)
        self.sub_paddle = rospy.Subscriber("/paddle_xyz", coordinates, self.PaddlePositionInputCallback)
=======

        # Initialize subscriber
        self.sub = rospy.Subscriber("/Goalie_coord", Goalie_coord, self.PositionInputCallback)
>>>>>>> 229818073219848cfbb19c771df3301f151447dd

        # Jonny added this, to be used for linear regression
        self.train_num = 10
        self.x_train = np.zeros(self.train_num)
        self.y_train = np.zeros(self.train_num)
        self.stop_flag = False
        self.train_count = 0  # Temporarily using this instead of self.msg_count

    def KeepingCallback(self, req: EmptyRequest) -> EmptyResponse:
         self.keeping = True
         return EmptyResponse()

    def StopingCallback(self, req: EmptyRequest) -> EmptyResponse:
         self.keeping = False
         return EmptyResponse()

    def BallPositionInputCallback(self, msg : coordinates) -> None:
        self.msg_count +=1
        #rospy.loginfo(f"x-coord: {msg.x}, y-coord: {msg.y}")

        # Don't want the arm to move
        if not self.keeping or self.stop_flag:
            self.msg_count = 0
            return

        JointState_msg = JointTrajectory()
        JointState_msg.joint_names = ['joint1','joint2','joint3','joint4','joint5','joint6']

        # Implementing trajectory prediction
        if self.msg_count <= self.train_num:
            rospy.logwarn('TRAIN')
            self.x_train[self.msg_count-1] = msg.x
            self.y_train[self.msg_count-1] = msg.y

        if self.msg_count == self.train_num:  # Once you have sufficient training data
            rospy.logwarn('MOVE!!')
            rospy.logwarn(self.x_train)
            rospy.logwarn(self.y_train)
            x_goal = -1.07
            y_predicted = traj_linear_reg(self.x_train, self.y_train, x_goal)

            # Ensure the arm doesn't move beyond the goal limits
            rospy.loginfo(f"predicted y-coord: {y_predicted}")
            if y_predicted < -0.25:
                rospy.logwarn('ball is too far right')
                y_predicted = -0.25
            if y_predicted > 0.25:
                y_predicted = 0.25
                rospy.logwarn('ball is too far left')

            value = joint_lookup_table(y_predicted)
            JointTrajectoryPoint_msg = JointTrajectoryPoint()
            JointTrajectoryPoint_msg.positions = value
            JointTrajectoryPoint_msg.time_from_start.nsecs = 10000000
            JointState_msg.points = [JointTrajectoryPoint_msg] 
            self.move_hdt_pub.publish(JointState_msg)

<<<<<<< HEAD
    def PaddlePositionInputCallback(self, msg : coordinates) -> None: # Added by Cody
        pass

        
        
        # if msg.y < -0.1:
        #     JointTrajectoryPoint_msg = JointTrajectoryPoint()
        #     JointTrajectoryPoint_msg.positions = [-0.5499488955653875, -1.0584790458580682, -0.5108311916967199, 0.10508089078446038, 0.0, -1.1244422327738606, 0.1372954704410103]
        #     JointTrajectoryPoint_msg.time_from_start.nsecs = 200000000
        #     JointState_msg.points =[JointTrajectoryPoint_msg] 
        #     self.move_hdt_pub.publish(JointState_msg)
        # elif msg.y < 0:
        #     JointTrajectoryPoint_msg = JointTrajectoryPoint()
        #     JointTrajectoryPoint_msg.positions = [-0.1411305394477424, -1.0584790458580682, -0.5115982054980662, 0.7693148427504655, 0.0, -2.19979558226155, 0.1380624842423567]
        #     JointTrajectoryPoint_msg.time_from_start.nsecs = 200000000
        #     JointState_msg.points =[JointTrajectoryPoint_msg] 
        #     self.move_hdt_pub.publish(JointState_msg)
        # elif msg.y < 0.1:
        #     JointTrajectoryPoint_msg = JointTrajectoryPoint()
        #     JointTrajectoryPoint_msg.positions = [0.2531145544443206, -1.0584790458580682, -0.5115982054980662, 0.7708488703531582, 0.0, -2.5948076899549593, 0.1380624842423567]
        #     JointTrajectoryPoint_msg.time_from_start.nsecs = 200000000
        #     JointState_msg.points =[JointTrajectoryPoint_msg] 
        #     self.move_hdt_pub.publish(JointState_msg)
        # else:
        #     JointTrajectoryPoint_msg = JointTrajectoryPoint()
        #     JointTrajectoryPoint_msg.positions = [0.5292395229290341, -1.0584790458580682, -0.5108311916967199, 0.10891595979119251, 0.0, -2.2089997478777073, 0.1380624842423567]
        #     JointTrajectoryPoint_msg.time_from_start.nsecs = 200000000
        #     JointState_msg.points =[JointTrajectoryPoint_msg] 
        #     self.move_hdt_pub.publish(JointState_msg)
=======
            self.stop_flag = True # No further movement commands
>>>>>>> c2477110f8f97a964d11fcfa699cbe30d5bb71c6

        # value = joint_lookup_table(msg.y - 0.04)
        # # rospy.loginfo(f"y-value: {msg.y}")
        # JointTrajectoryPoint_msg = JointTrajectoryPoint()
        # JointTrajectoryPoint_msg.positions = value
        # JointTrajectoryPoint_msg.time_from_start.nsecs = 10000000
        # JointState_msg.points = [JointTrajectoryPoint_msg] 
        # self.move_hdt_pub.publish(JointState_msg)


    def StepCallback(self, req: MoveitRequest) -> MoveitResponse:
        """ Step callback function
            parameter
                req: MoveitRequest (Pose, bool)
            return
                rtn: MoveitResponse (MoveItErrorCodes)
        """ 
        res = MoveitResponse()
        self.move_group_commander.set_pose_target(req.pose)
        succ, plan, time, error_code = self.move_group_commander.plan()
        if not succ:
            self.move_group_commander.clear_pose_targets()
            res.code = error_code
            return res
        self.now_keep = True
        self.move_group_commander.execute(plan, wait=True)
        self.move_group_commander.stop()
        self.move_group_commander.clear_pose_targets()
        if req.open:
            self.pincer_pos_publisher.publish(0.8)
        else:
            self.pincer_pos_publisher.publish(0.1)
        self.move_group_grap.stop()
        res.code.val = moveit_msgs.msg.MoveItErrorCodes.SUCCESS
        return res


    def ResetCallback(self, req: EmptyRequest) -> EmptyResponse:
        self.move_group_commander.set_pose_target(self.home_pose)
        succ, plan, time, error_code = self.move_group_commander.plan()
        self.move_group_commander.execute(plan, wait=True)
        self.move_group_commander.stop()
        self.move_group_commander.clear_pose_targets()
        self.now_keep = True
        return EmptyResponse()


    def KeeperCallback(self, req: KeeperRequest) -> KeeperResponse:
        res = KeeperResponse()
        if  -0.3 < req.pos < 0.3:
            if not self.now_keep:
                pose = copy.deepcopy(self.home_pose)
                pose.position.y = req.pos
                self.move_group_commander.set_pose_target(pose)
                succ, plan, time, error_code = self.move_group_commander.plan()
                if not succ:
                    self.move_group_commander.clear_pose_targets()
                    res.code = error_code
                    return res
                self.move_group_commander.execute(plan, wait=True)
                self.move_group_commander.stop()
                self.move_group_commander.clear_pose_targets()
                res.code.val = moveit_msgs.msg.MoveItErrorCodes.SUCCESS
                return res
            else:
                waypoints = []
                wpose = copy.deepcopy(self.home_pose)
                wpose.position.y = self.current_y
                for i in range(4):
                    pose = copy.deepcopy(wpose)
                    pose.position.y += (1 + i) / 4 * (req.pos - wpose.position.y)
                    waypoints.append(pose)
                plan, fraction = self.move_group_commander.compute_cartesian_path(
                        waypoints, 0.03, 0.0)
                self.move_group_commander.execute(plan, wait=True)
            res.code.val = moveit_msgs.msg.MoveItErrorCodes.SUCCESS
            self.current_y = req.pos
            return res
        res.code.val = moveit_msgs.msg.MoveItErrorCodes.PLANNING_FAILED
        return res

    def CloseCallback(self, req: EmptyRequest) -> EmptyResponse:
        # self.move_group_grap.go([0.0, 0.0, 0.0], wait=True)
        # self.move_group_grap.stop()
        self.pincer_pos_publisher.publish(0.1)
        return EmptyResponse()
    
    def OpenCallback(self, req: EmptyRequest) -> EmptyResponse:
        # self.move_group_grap.go([0.3, 0.0, 0.0], wait=True)
        # self.move_group_grap.stop()
        self.pincer_pos_publisher.publish(0.8)
        return EmptyResponse()
    
    def Move_hdt(self,req:EmptyRequest) -> EmptyResponse:  ### Marco added this
        JointState_msg = JointTrajectory()
        JointState_msg.joint_names = ['joint1','joint2','joint3','joint4','joint5','joint6']

        
        JointTrajectoryPoint_msg = JointTrajectoryPoint()
        JointTrajectoryPoint_msg.positions = [-1, -1.1167720947603965, -0.5238704263196091, 0.3766037764610953, 0.02224340023904636, -2.3946170878035424]
        JointTrajectoryPoint_msg.time_from_start.nsecs = 500000000

        JointState_msg.points =[JointTrajectoryPoint_msg] 
        self.move_hdt_pub.publish(JointState_msg)
        rospy.sleep(1)
        JointState_msg = JointTrajectory()
        JointState_msg.joint_names = ['joint1','joint2','joint3','joint4','joint5','joint6']

        
        JointTrajectoryPoint_msg = JointTrajectoryPoint()
        JointTrajectoryPoint_msg.positions = [1, -1.1167720947603965, -0.5238704263196091, 0.3766037764610953, 0.02224340023904636, -2.3946170878035424]
        # JointTrajectoryPoint_msg.velocities = [0.0, 0.0012207403790398877, 0.0, 0.0, 0.0, 0.0, 0.0004882961516159551]
        # JointTrajectoryPoint_msg.accelerations = []
        # JointTrajectoryPoint_msg.accelerations = [0,0,0,0,0,0,0]
        # JointTrajectoryPoint_msg.effort = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 16.203619495223855]
        JointTrajectoryPoint_msg.time_from_start.nsecs = 500000000

        JointState_msg.points =[JointTrajectoryPoint_msg] 
        self.move_hdt_pub.publish(JointState_msg)
        rospy.logerr('erOR')

        return EmptyResponse()


def main():
    motion_control = MotionControl()
    rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
