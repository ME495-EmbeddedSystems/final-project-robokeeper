#!/usr/bin/env python3
""" Use the node to use moveit control the Adroit follow commend
    Offers three Service
    SERVICE:
        reset (std_srvs/Empty) - reset to keeper Home
        keep (std_srvs/Empty) - reset to keeper Home
        step (std_srvs/Pose) - move to a new point and add the point to
        close (std_srvs/Empty) - close the pincer
        open (std_srvs/Empty) - open the pincer

    SUBSCRIBERS:
        goalie_coord (robokeeper/GoalieCoord) - 
"""
import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from std_msgs.msg import Float64
from std_srvs.srv import Empty, EmptyRequest, EmptyResponse
from robokeeper.srv import Moveit, MoveitRequest, MoveitResponse, Keeper, KeeperRequest, KeeperResponse
from robokeeper.msg import Goalie_coord
from tf.transformations import quaternion_from_euler
from  geometry_msgs.msg import Pose

class MotionControl():
    """ class MotionControl contain all function for the node
        Provide four service
    """
    def __init__(self) -> None:
        moveit_commander.roscpp_initialize(sys.argv)
        rospy.init_node('motion', anonymous=True)
        self.scene = moveit_commander.PlanningSceneInterface()
        rospy.sleep(1)
        self.robot = moveit_commander.RobotCommander()
        base_pose = geometry_msgs.msg.PoseStamped()
        base_pose.header.frame_id = 'base_link'
        base_pose.pose.position.x = 0
        base_pose.pose.position.y = 0
        base_pose.pose.position.z = -1
        base_pose.pose.orientation.w = 1.0
        # Adding collision object to the planning scene to simulate table
        self.scene.attach_box('base_link','table', pose=base_pose, size=(5, 5, 1))
        rospy.sleep(1)
        
        group_name = "arm"
        # grap_group_name = "pincer"
        self.move_group_commander = moveit_commander.MoveGroupCommander(group_name)
        # self.move_group_grap = moveit_commander.MoveGroupCommander(grap_group_name)
        # self.move_group_grap.set_max_velocity_scaling_factor(1)
        # self.move_group_grap.set_max_acceleration_scaling_factor(1)
        self.move_group_commander.set_max_velocity_scaling_factor(1)
        self.move_group_commander.set_max_acceleration_scaling_factor(1)
        self.display_trajectory_publisher =\
            rospy.Publisher('/move_group/display_planned_path',moveit_msgs.msg.DisplayTrajectory,queue_size=20)
        self.pincer_pos_publisher = rospy.Publisher("/pincer_joint_position_controller/command", Float64,queue_size=10)
        self.reset_srv = rospy.Service("reset", Empty, self.ResetCallback)
        self.step_srv = rospy.Service("step", Moveit, self.StepCallback)
        self.keeper_srv = rospy.Service("keep", Keeper, self.KeeperCallback)
        self.keeping_srv = rospy.Service("start_keeping", Empty, self.KeepingCallback)
        self.stoping_srv = rospy.Service("stop_keeping", Empty, self.StopingCallback)
        self.close_srv = rospy.Service("close", Empty, self.CloseCallback)
        self.open_srv = rospy.Service("open", Empty, self.OpenCallback)

        quaternion = quaternion_from_euler(0, 1.5707, 0, axes='sxyz')
        self.home_pose = Pose()
        self.home_pose.position.x = 0.25
        self.home_pose.position.z = -0.22
        self.home_pose.orientation.x = quaternion[0]
        self.home_pose.orientation.y = quaternion[1]
        self.home_pose.orientation.z = quaternion[2]
        self.home_pose.orientation.w = quaternion[3]

        self.now_keep = True
        self.current_y = 0

        self.keeping = False
        self.position_buffer = []
        self.sub = rospy.Subscriber("/Goalie_coord", Goalie_coord, self.PositionInputCallback)
        self.time = rospy.Timer(rospy.Duration(0.3), self.TimerCallback)


    def KeepingCallback(self, req: EmptyRequest) -> EmptyResponse:
         self.keeping = True
         return EmptyResponse()

    def StopingCallback(self, req: EmptyRequest) -> EmptyResponse:
         self.keeping = False
         return EmptyResponse()

    def PositionInputCallback(self, msg : Goalie_coord) -> None:
        if len(self.position_buffer) == 0:
            self.position_buffer.append(msg.y)
        elif self.position_buffer[-1] - 0.04 < msg.y < self.position_buffer[-1] + 0.04 and -0.2 < msg.y < 0.2:
            self.position_buffer.append(msg.y)
        if len(self.position_buffer) > 15:
            self.position_buffer = []

    def TimerCallback(self, event) -> None:
        if not self.keeping:
            return
        points = self.position_buffer
        self.position_buffer = []
        waypoints = []
        wpose = self.home_pose
        for p in points:
            pose = copy.deepcopy(wpose)
            pose.position.y = p
            waypoints.append(pose)
        plan, fraction = self.move_group_commander.compute_cartesian_path(
                waypoints, 0.01, 0.0)
        self.move_group_commander.execute(plan, wait=True) 
        self.position_buffer = []

    def StepCallback(self, req: MoveitRequest) -> MoveitResponse:
        """ Step callback function
            parameter
                req: MoveitRequest (Pose, bool)
            return
                rtn: MoveitResponse (MoveItErrorCodes)
        """ 
        res = MoveitResponse()
        self.move_group_commander.set_pose_target(req.pose)
        succ, plan, time, error_code = self.move_group_commander.plan()
        if not succ:
            self.move_group_commander.clear_pose_targets()
            res.code = error_code
            return res
        self.now_keep = True
        self.move_group_commander.execute(plan, wait=True)
        self.move_group_commander.stop()
        self.move_group_commander.clear_pose_targets()
        if req.grep:
            self.move_group_grap.go([0.3, 0, 0], wait=True)
        else:
            self.move_group_grap.go([0, 0, 0], wait=True)
        self.move_group_grap.stop()
        res.code.val = moveit_msgs.msg.MoveItErrorCodes.SUCCESS
        return res


    def ResetCallback(self, req: EmptyRequest) -> EmptyResponse:
        self.move_group_commander.set_pose_target(self.home_pose)
        succ, plan, time, error_code = self.move_group_commander.plan()
        self.move_group_commander.execute(plan, wait=True)
        self.move_group_commander.stop()
        self.move_group_commander.clear_pose_targets()
        self.now_keep = True
        return EmptyResponse()


    def KeeperCallback(self, req: KeeperRequest) -> KeeperResponse:
        res = KeeperResponse()
        if  -0.2 < req.pos < 0.2:
            if not self.now_keep:
                pose = copy.deepcopy(self.home_pose)
                pose.position.y = req.pos
                self.move_group_commander.set_pose_target(pose)
                succ, plan, time, error_code = self.move_group_commander.plan()
                if not succ:
                    self.move_group_commander.clear_pose_targets()
                    res.code = error_code
                    return res
                self.move_group_commander.execute(plan, wait=True)
                self.move_group_commander.stop()
                self.move_group_commander.clear_pose_targets()
                res.code.val = moveit_msgs.msg.MoveItErrorCodes.SUCCESS
                return res
            else:
                waypoints = []
                wpose = copy.deepcopy(self.home_pose)
                wpose.position.y = self.current_y
                for i in range(4):
                    pose = copy.deepcopy(wpose)
                    pose.position.y += (1 + i) / 4 * (req.pos - wpose.position.y)
                    waypoints.append(pose)
                plan, fraction = self.move_group_commander.compute_cartesian_path(
                        waypoints, 0.03, 0.0)
                self.move_group_commander.execute(plan, wait=True)
            res.code.val = moveit_msgs.msg.MoveItErrorCodes.SUCCESS
            self.current_y = req.pos
            return res
        res.code.val = moveit_msgs.msg.MoveItErrorCodes.PLANNING_FAILED
        return res

    def CloseCallback(self, req: EmptyRequest) -> EmptyResponse:
        # self.move_group_grap.go([0.0, 0.0, 0.0], wait=True)
        # self.move_group_grap.stop()
        self.pincer_pos_publisher.publish(0.1)
        return EmptyResponse()
    
    def OpenCallback(self, req: EmptyRequest) -> EmptyResponse:
        # self.move_group_grap.go([0.3, 0.0, 0.0], wait=True)
        # self.move_group_grap.stop()
        self.pincer_pos_publisher.publish(0.8)
        return EmptyResponse()



def main():
    motion_control = MotionControl()
    rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
