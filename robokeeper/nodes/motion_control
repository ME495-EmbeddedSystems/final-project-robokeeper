#!/usr/bin/env python3
""" The motion_control node publishes jointTrajectory messages to actuate the HDT Adroit 6-dof arm to mimic a goalkeeper.
    It also actuates the arm to a specified position using moveit commander when performing the step service.

    SUBSCRIBERS:
        goalie_coord (robokeeper/GoalieCoord) - 

    PUBLIHSERS:
        move_group/display_planned_path (moveit_msgs/DisplayTrajectory)
        pincer_joint_position_controller/command (std_msgs/Float64)
        arm_controller/command (trajectory_msgs/JointTrajectory)

    
    SERVICE:
        reset (std_srvs/Empty) - resets arm position to keeper Home
        step (std_srvs/Pose) - move to a new point and add the point to
        keep (std_srvs/Empty) - reset to keeper Home
        start_keeping (std_srvs/Empty) - 
        stop_keeping (std_srvs/Empty) - 
        close (std_srvs/Empty) - close the pincer
        open (std_srvs/Empty) - open the pincer
        move_hdt (std_srvs/Empty) - 

    
"""
import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from std_msgs.msg import Float64
from std_srvs.srv import Empty, EmptyRequest, EmptyResponse
from robokeeper.srv import Moveit, MoveitRequest, MoveitResponse, Keeper, KeeperRequest, KeeperResponse
from robokeeper.msg import Goalie_coord
from tf.transformations import quaternion_from_euler
from geometry_msgs.msg import Pose
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint  ### Marco added this
import numpy as np
from robokeeper_library.robokeeper_functions import joint_lookup_table, traj_linear_reg

class MotionControl():
    """ class MotionControl contain all function for the node
        Provide four service
    """
    def __init__(self) -> None:
        moveit_commander.roscpp_initialize(sys.argv)
        rospy.init_node('motion', anonymous=True)
        self.scene = moveit_commander.PlanningSceneInterface()
        rospy.sleep(1)
        self.robot = moveit_commander.RobotCommander()

        # Adding collision object to the planning scene to simulate table
        base_pose = geometry_msgs.msg.PoseStamped()
        base_pose.header.frame_id = 'base_link'
        base_pose.pose.position.x = 0
        base_pose.pose.position.y = 0
        base_pose.pose.position.z = -1
        base_pose.pose.orientation.w = 1.0
        self.scene.attach_box('base_link','table', pose=base_pose, size=(5, 5, 1))

        rospy.sleep(1)
        
        # Initialize arm move group for moveit
        group_name = "arm"
        self.move_group_commander = moveit_commander.MoveGroupCommander(group_name)
        self.move_group_commander.set_max_velocity_scaling_factor(1)
        self.move_group_commander.set_max_acceleration_scaling_factor(1)
        
        # Initialize publishers
        self.display_trajectory_publisher =\
            rospy.Publisher('/move_group/display_planned_path',moveit_msgs.msg.DisplayTrajectory,queue_size=20)
        self.pincer_pos_publisher = rospy.Publisher("/pincer_joint_position_controller/command", Float64,queue_size=10)
        self.move_hdt_pub = rospy.Publisher("/arm_controller/command", JointTrajectory,queue_size=10) ### Marco added this
        
        # Initialize services
        self.paddle_srv = rospy.Service("grab_paddle",Empty, self.PaddleCallback)
        self.reset_srv = rospy.Service("reset", Empty, self.ResetCallback)
        self.step_srv = rospy.Service("step", Moveit, self.StepCallback)
        self.keeper_srv = rospy.Service("keep", Keeper, self.KeeperCallback)
        self.keeping_srv = rospy.Service("start_keeping", Empty, self.KeepingCallback)
        self.stoping_srv = rospy.Service("stop_keeping", Empty, self.StopingCallback)
        self.close_srv = rospy.Service("close", Empty, self.CloseCallback)
        self.open_srv = rospy.Service("open", Empty, self.OpenCallback)
        self.Move_hdt_srv = rospy.Service("Move_hdt", Empty, self.Move_hdt)### Marco added this

        quaternion = quaternion_from_euler(0, 1.5707, 0, axes='sxyz')
        self.home_pose = Pose()
        self.home_pose.position.x = 0.25
        self.home_pose.position.z = -0.22
        self.home_pose.orientation.x = quaternion[0]
        self.home_pose.orientation.y = quaternion[1]
        self.home_pose.orientation.z = quaternion[2]
        self.home_pose.orientation.w = quaternion[3]

        self.now_keep = True
        self.current_y = 0

        self.msg_count = 0
        self.keeping = False

        # Initialize subscriber
        self.sub = rospy.Subscriber("/Goalie_coord", Goalie_coord, self.PositionInputCallback)

        # Jonny added this, to be used for linear regression
        self.train_num = 15
        self.x_train = np.zeros(self.train_num)
        self.y_train = np.zeros(self.train_num)
        self.stop_flag = False
        self.train_count = 0  # Temporarily using this instead of self.msg_count

        self.pre_y = [0, 0, 0, 0]

    def PaddleCallback(self, req: EmptyRequest) -> EmptyResponse:
        quaternion = quaternion_from_euler(0, 1.5707, 0, axes='sxyz')
        paddle_pose = Pose()
        paddle_pose.position.x = 0
        paddle_pose.position.y = 0.25
        paddle_pose.position.z = -0.22
        paddle_pose.orientation.x = quaternion[0]
        paddle_pose.orientation.y = quaternion[1]
        paddle_pose.orientation.z = quaternion[2]
        paddle_pose.orientation.w = quaternion[3]


        self.move_group_commander.set_pose_target(paddle_pose)
        succ, plan, time, error_code = self.move_group_commander.plan()
        self.move_group_commander.execute(plan, wait=True)
        self.move_group_commander.stop()
        self.move_group_commander.clear_pose_targets()
        self.now_keep = True
        return EmptyResponse()


    def KeepingCallback(self, req: EmptyRequest) -> EmptyResponse:
         self.keeping = True
         return EmptyResponse()

    def StopingCallback(self, req: EmptyRequest) -> EmptyResponse:
         self.keeping = False
         self.stop_flag = False
         self.x_train = np.zeros(self.train_num)
         self.y_train = np.zeros(self.train_num)

         return EmptyResponse()

    def PositionInputCallback(self, msg : Goalie_coord) -> None:
        self.msg_count +=1
        #rospy.loginfo(f"x-coord: {msg.x}, y-coord: {msg.y}")

        # Don't want the arm to move
        if not self.keeping or self.stop_flag:
            self.msg_count = 0
            return

        JointState_msg = JointTrajectory()
        JointState_msg.joint_names = ['joint1','joint2','joint3','joint4','joint5','joint6']

        # Implementing trajectory prediction
        # if self.msg_count <= self.train_num:
        #     rospy.logwarn('TRAIN')
        #     self.x_train[self.msg_count-1] = msg.x
        #     self.y_train[self.msg_count-1] = msg.y

        # if self.msg_count == self.train_num:  # Once you have sufficient training data
        #     rospy.logwarn('MOVE!!')
        #     rospy.logwarn(self.x_train)
        #     rospy.logwarn(self.y_train)
        #     x_goal = -1.07
        #     y_predicted = traj_linear_reg(self.x_train, self.y_train, x_goal)

        #     # Ensure the arm doesn't move beyond the goal limits
        #     rospy.loginfo(f"predicted y-coord: {y_predicted}")
        #     if y_predicted < -0.25:
        #         rospy.logwarn('ball is too far right')
        #         y_predicted = -0.25
        #     if y_predicted > 0.25:
        #         y_predicted = 0.25
        #         rospy.logwarn('ball is too far left')

        #     value = joint_lookup_table(y_predicted)
        #     JointTrajectoryPoint_msg = JointTrajectoryPoint()
        #     JointTrajectoryPoint_msg.positions = value
        #     JointTrajectoryPoint_msg.time_from_start.nsecs = 10000000
        #     JointState_msg.points = [JointTrajectoryPoint_msg] 
        #     self.move_hdt_pub.publish(JointState_msg)

        #     self.stop_flag = True # No further movement commands
        rospy.logerr(msg.y)
        value = joint_lookup_table(msg.y + (msg.y-self.pre_y[0]) * 4)
        rospy.logerr(value)
        # rospy.loginfo(f"y-value: {msg.y}")
        JointTrajectoryPoint_msg = JointTrajectoryPoint()
        JointTrajectoryPoint_msg.positions = value
        JointTrajectoryPoint_msg.time_from_start.nsecs = 10000000
        JointState_msg.points = [JointTrajectoryPoint_msg] 
        self.move_hdt_pub.publish(JointState_msg)
        self.pre_y.pop(0)
        self.pre_y.append(msg.y)


    def StepCallback(self, req: MoveitRequest) -> MoveitResponse:
        """ Step callback function
            parameter
                req: MoveitRequest (Pose, bool)
            return
                rtn: MoveitResponse (MoveItErrorCodes)
        """ 
        res = MoveitResponse()
        self.move_group_commander.set_pose_target(req.pose)
        succ, plan, time, error_code = self.move_group_commander.plan()
        if not succ:
            self.move_group_commander.clear_pose_targets()
            res.code = error_code
            return res
        self.now_keep = True
        self.move_group_commander.execute(plan, wait=True)
        self.move_group_commander.stop()
        self.move_group_commander.clear_pose_targets()
        if req.open:
            self.pincer_pos_publisher.publish(0.8)
        else:
            self.pincer_pos_publisher.publish(0.1)
        self.move_group_grap.stop()
        res.code.val = moveit_msgs.msg.MoveItErrorCodes.SUCCESS
        return res


    def ResetCallback(self, req: EmptyRequest) -> EmptyResponse:
        self.move_group_commander.set_pose_target(self.home_pose)
        succ, plan, time, error_code = self.move_group_commander.plan()
        self.move_group_commander.execute(plan, wait=True)
        self.move_group_commander.stop()
        self.move_group_commander.clear_pose_targets()
        self.now_keep = True
        return EmptyResponse()


    def KeeperCallback(self, req: KeeperRequest) -> KeeperResponse:
        res = KeeperResponse()
        if  -0.3 < req.pos < 0.3:
            if not self.now_keep:
                pose = copy.deepcopy(self.home_pose)
                pose.position.y = req.pos
                self.move_group_commander.set_pose_target(pose)
                succ, plan, time, error_code = self.move_group_commander.plan()
                if not succ:
                    self.move_group_commander.clear_pose_targets()
                    res.code = error_code
                    return res
                self.move_group_commander.execute(plan, wait=True)
                self.move_group_commander.stop()
                self.move_group_commander.clear_pose_targets()
                res.code.val = moveit_msgs.msg.MoveItErrorCodes.SUCCESS
                return res
            else:
                waypoints = []
                wpose = copy.deepcopy(self.home_pose)
                wpose.position.y = self.current_y
                for i in range(4):
                    pose = copy.deepcopy(wpose)
                    pose.position.y += (1 + i) / 4 * (req.pos - wpose.position.y)
                    waypoints.append(pose)
                plan, fraction = self.move_group_commander.compute_cartesian_path(
                        waypoints, 0.03, 0.0)
                self.move_group_commander.execute(plan, wait=True)
            res.code.val = moveit_msgs.msg.MoveItErrorCodes.SUCCESS
            self.current_y = req.pos
            return res
        res.code.val = moveit_msgs.msg.MoveItErrorCodes.PLANNING_FAILED
        return res

    def CloseCallback(self, req: EmptyRequest) -> EmptyResponse:
        # self.move_group_grap.go([0.0, 0.0, 0.0], wait=True)
        # self.move_group_grap.stop()
        self.pincer_pos_publisher.publish(0.1)
        return EmptyResponse()
    
    def OpenCallback(self, req: EmptyRequest) -> EmptyResponse:
        # self.move_group_grap.go([0.3, 0.0, 0.0], wait=True)
        # self.move_group_grap.stop()
        self.pincer_pos_publisher.publish(0.8)
        return EmptyResponse()
    
    def Move_hdt(self,req:EmptyRequest) -> EmptyResponse:  ### Marco added this
        JointState_msg = JointTrajectory()
        JointState_msg.joint_names = ['joint1','joint2','joint3','joint4','joint5','joint6']

        
        JointTrajectoryPoint_msg = JointTrajectoryPoint()
        JointTrajectoryPoint_msg.positions = [-1, -1.1167720947603965, -0.5238704263196091, 0.3766037764610953, 0.02224340023904636, -2.3946170878035424]
        JointTrajectoryPoint_msg.time_from_start.nsecs = 500000000

        JointState_msg.points =[JointTrajectoryPoint_msg] 
        self.move_hdt_pub.publish(JointState_msg)
        rospy.sleep(1)
        JointState_msg = JointTrajectory()
        JointState_msg.joint_names = ['joint1','joint2','joint3','joint4','joint5','joint6']

        
        JointTrajectoryPoint_msg = JointTrajectoryPoint()
        JointTrajectoryPoint_msg.positions = [1, -1.1167720947603965, -0.5238704263196091, 0.3766037764610953, 0.02224340023904636, -2.3946170878035424]
        # JointTrajectoryPoint_msg.velocities = [0.0, 0.0012207403790398877, 0.0, 0.0, 0.0, 0.0, 0.0004882961516159551]
        # JointTrajectoryPoint_msg.accelerations = []
        # JointTrajectoryPoint_msg.accelerations = [0,0,0,0,0,0,0]
        # JointTrajectoryPoint_msg.effort = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 16.203619495223855]
        JointTrajectoryPoint_msg.time_from_start.nsecs = 500000000

        JointState_msg.points =[JointTrajectoryPoint_msg] 
        self.move_hdt_pub.publish(JointState_msg)
        rospy.logerr('erOR')

        return EmptyResponse()


def main():
    motion_control = MotionControl()
    rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
